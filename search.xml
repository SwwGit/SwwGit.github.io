<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Swift使用Perfect Assistant 开发服务器编译/测试/部署自动化 详解]]></title>
      <url>%2F2017%2F04%2F20%2Fuse-perfect-assistant-dyploy-aws%2F</url>
      <content type="text"><![CDATA[Perfect Assistant是一个macOS客户端程序，为Swift的服务器项目(Perfect)提供软件组件下载、管理、便利、测试和部署的一揽子集成环境。无论是刚刚从前端转向全栈的Swift发烧友，还是资深的服务器工程师，Perfect Assistant 都能够为您的研发工作提供非常大的便利。 以下将 Perfect Assistant 简称PA 本文具体介绍下PA从项目的创建到部署到AWS服务的全过程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift Package Manager 使用详解]]></title>
      <url>%2F2017%2F04%2F14%2FswiftPackageDemo%2F</url>
      <content type="text"><![CDATA[Swift Package Manager(SPM)是苹果官方的Swift包管理工具,可以用来管理 Swift 代码的分配，它为 Swift 编译系统集成了自动进行下载、编译和连接依赖的过程。 官方有一个对于SPM的示例教程，大家可以去看看:Package Manager 开始一个项目 创建项目目录 1mkdir "projectName" 创建swift工程 123cd "projectName"//swift package init //可以通过参数--type 指定工程类型 empty|library|executable|system-module 默认为library 这里为了演示方便 我创建了一个可执行项目swift package init --type executable 我们来看一下每个文件，目录都是干什么的: - Package.swift 管理工程的包和依赖，稍后会详解。 - .gitignore 熟悉git的童鞋该知道，这里可以添加需要被git忽略的文件，路径。 - Sources/ 项目的所有源文件都在这个目录底下。 - main.swift swift应用程序的入口文件。 - Tests/ 测试代码的目录。 我们给main.swift中添加一条打印语句: 1print("Hello Swift Package Manager！") 终端执行: 1swift build 就会生成可执行文件.build/debug/projectName，运行一下: 1./.build/debug/Car 成功运行。 Package.swift接下来看一下Package.swift中的内容 123456import PackageDescription //包管理描述//这里固定写法let package = Package( name: "MyCar"//你的项目名 若修改则build后的可执行文件名也会改变) 在Sources下新建一个文件Car.swift并编辑: 12touch Sources/Car.swiftvim Sources/Car.swift Car.swift: 1234567struct Car&#123; var name:String var number:String func showInfo()&#123; print("name:\(name),number:\(number)") &#125;&#125; 编辑main.swift: 12let car = Car(name:"BMW",number:"京A66666")car.showInfo() bulid后执行: Target 我们在Sources下新建一个文件夹,并把Car.swift移进去: 12mkdir Sources/Carmv Sources/Car.swift Sources/Car 然后重新编译一下，这个是就会报错了: 意思是说文件布局有错，main不在一个模块中，解决办法是把main.swift移动到一个模块中。 为什么呢？ Swift通过 Modules 来管理代码，默认情况下，所有在 Sources 目录下的文件都在同一个module中，我们在Sources中新建了一个文件夹，就是新增了一个module－Car，也就没有了默认的module了，所以main.swift被孤立在外边。 我们再创建一个文件夹Application,把main.swift放进去： 我们现在的Sources文件目录结构应该是这样的: Sources Application main.swift Car Car.swift 重新编译，还是会报错： 因为module直接是相互独立的，所以我们需要在main.swift中import Car ,当然这也是不够的，我们还需要编辑Car.swift: 1234567891011public struct Car&#123; var name:String var number:String public init(name:String,number:String)&#123; self.name = name self.number = number &#125; public func showInfo()&#123; print("name:\(name),number:\(number)") &#125;&#125; 当然，这还是不够的，因为SPM并不知道Application和Car这两个module直接的依赖关系，接下来就是重点了，我们在Package.swift中添加依赖: 12345678import PackageDescriptionlet package = Package( name: "Car", targets: [ Target(name: "Application", dependencies: ["Car"]) //添加Application和Car之间的依赖 ] //我们可以添加多个Target) 现在就可以编译通过了。 dependencies 依赖可以是本地的可以是远程的库，可以是library也可以是executable 这里为了方便演示，我建立了一个气车引擎库Engine，提交到了github 123456public struct Engine &#123; public var model:String public init(model:String)&#123; self.model = model &#125;&#125; 我们给工程添加一个来自远程依赖库Engine: 1234567891011121314// swift-tools-version:3.1import PackageDescriptionlet package = Package( name: "Car", targets: [ Target(name: "Application", dependencies: ["Car"]) //添加Application和Car之间的依赖 ], //我们可以添加多个Target dependencies: [ //我们可以添加多个依赖包 .Package(url: "https://github.com/SwwGit/Engine.git", majorVersion: 1) // url 远程库地址 majorVersion 指定主要版本号 ]) 然后执行swift build。 SPM会自动把依赖下载下来。（ps ： 可以使用swift package clean 命令清除build命令生成的东西，但是不会清除下载的依赖包，要一起清除依赖包可以使用swift package reset命令） 我们修改一下Car.swift中的内容: 1234567891011121314import Enginepublic struct Car&#123; var name:String var number:String var engine:Engine public init(name:String,number:String,engine:Engine)&#123; self.name = name self.number = number self.engine = engine &#125; public func showInfo()&#123; print("name:\(name),number:\(number),engine:\(engine.model)") &#125;&#125; 将main.swift修改如下： 123456import Carimport Enginelet engine = Engine(model:"Mach")let car = Car(name:"BMW",number:"京A66666",engine:engine)car.showInfo() 编译后执行: 相信到这里，大家应该很清楚SPM的懂法了！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Tableview可能产生的循环引用]]></title>
      <url>%2F2017%2F04%2F12%2Fcircular-reference%2F</url>
      <content type="text"><![CDATA[循环引用在iOS开发中是个老生常谈的问题了,虽然ARC可以让你不用太去关心对象的释放问题，但是它并不能解决所有问题，例如循环引用。虽然这是这个大家都懂的问题，但是总会有很多人有疏忽。本文讲的就是一个实在的例子。 同事的代码出现了一个有趣的问题，让我帮忙检查，所有就有了这篇文章。 故事背景 公司测试童鞋在测试同事的模块时，发现了一个问题，有一个本该发送一次的请求，会经常同时发送好多次。然而他看了半天也没找到问题，我便去看了一下。问题是这个样子的： 有一个控制器A，里面注册了一个通知，然后在收到通知后，发送一个请求。然后在另一个控制器里发送的通知。 检查后，确信通知是只发送了一次，但是有时候会发送多次请求，而有时候只发送一次。测试了一下，我发现如果控制器A被多次用到过，请求就会发送多次，所以我在A控制器中发送请求的方法里打印了一下当前执行请求方法的A的实例(self)，并在dealloc中打印了标记。果然，每一个实例的地址都不一样，并且dealloc一次都没有执行过。所以，很明显，那些本该被销毁的对象都没被销毁，导致每一个都发送了请求。 查看代码，寻找问题我看到控制A中，定义了一些实例变量: 12UITableView *_tableView;AObject *_someObj; 这这意味着，_tableView是被A强引用的，_tableView的dataSource和delegate是A，但是dataSource和delegate都是weak声明的，所以_tableView和A之间是不存在循环引用的。 在实现dataSource的方法中，我注意到cell有一个block在这里实现了: 123456789- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; ...... cell.clickButtonBlock = ^(NSInteger buttonTag)&#123; otherObj = _someObj; [self doSomeThing]; &#125; ...... return cell;&#125; 这里cell其实是被_tableView所持有的，而_tableView是被A持有的，在cell实现block时，捕获了self，强持有了A,结果导致了循环引用。致使A控制器在该从界面中被pop或者dismiss后等该销毁时没有被销毁。我们将代码修改如下: 1234567891011- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; ...... __weak typeof(self)weakSelf = self; cell.clickButtonBlock = ^(NSInteger buttonTag)&#123; //这里我们不担心self会提前销毁，所以不再使用strong声明。 otherObj = _someObj; [weakSelf doSomeThing]; &#125; ...... return cell;&#125; 我们用声明了一个weakSelf来断开block与A直接的强引用,但是这样改完后，还是不行的，因为这里的_someObj作为A的一个成员变量，也是被强引用，所以这里我们同样的需要把_someObj处理下： 123456789101112- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; ...... __weak typeof(self)weakSelf = self; __weak typeof(_someObj)weakSomeObj = _someObj; cell.clickButtonBlock = ^(NSInteger buttonTag)&#123; //这里我们不担心self会提前销毁，所以不再使用strong声明。 otherObj = weakSomeObj; [weakSelf doSomeThing]; &#125; ...... return cell;&#125; 这样,这个问题就此解决了。 虽然这是一个简单的小问题，也是比较常见的问题，所以我希望大家都注意下类似的问题，不要疏忽了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ubuntu中使用CLion编写swift(3.1)代码]]></title>
      <url>%2F2017%2F04%2F09%2Fswift-on-Linux-with-CLion%2F</url>
      <content type="text"><![CDATA[苹果开源swift是对广大开发者的福利，swift不仅可以在mac上运行，也支持Linux，后期还将会支持更多平台。如果你想学习swift开发，又没有mac，那么你就该用Ubuntu了。 本文不涉及swift的教程，我也是参考别人的帖子来的，想在Ubuntu中使用可以支持swift的IDE，请大家看这篇帖子:手把手教你在Ubuntu上优雅地玩Swift因为帖子是基于swift2.2的，所以需要修改一点东西。在添加Extermal Tools时我们将clean命令修改下，因为在swift3以后,之前的清除命令开始废除了。修改如下：clean 命令现在是swift-package的一部分了。我们再添加一个reset的命令，clean只是清除编译生成的东西，而reset会将swift包依赖等全部删除重置。添加如下: 剩下的按照原贴来便可以了。ps:现在的CLion在安装时就会提示安装swift插件，我们选上就可以了，不需要单独下载。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[细谈OC中的深浅拷贝]]></title>
      <url>%2F2017%2F04%2F07%2Ftalking-about-oc-copy%2F</url>
      <content type="text"><![CDATA[关于深浅拷贝，已经是个老生常谈的问题了，自己曾经也有在面试中被问过，最近有个朋友问到过这个问题，借此机会，我们来细谈一下深浅拷贝的问题。 深浅拷贝的概念什么是深拷贝什么是浅拷贝呢，简单来说就是： 深拷贝是对一个对象的内容的拷贝，分配新的内存去存储。拷贝后的对象和原来的对象并不是同一个对象，只是内容一样而已。 浅拷贝则是对对象地址的拷贝，和原来的对象的内容是同一份，并没有分配新的内存。 深浅拷贝演示 我们定义一个Person类如下: 然后我们生成一个Person对象p1,再定义一个p2，将p1赋值给p2: 这里实际上就是进行了一次浅拷贝，把p1的地址赋给了p2。p1和p2都是指向同一个对象,但是对象的引用计数增加了1。如果我们对p2的属性进行修改,则p1也会改变，因为操作的就是同一个对象。 如何进行深拷贝呢,我们可以遵守NSCopying,NSMutableCopying协议,实现: 12- (id)copyWithZone:(nullable NSZone *)zone;- (id)mutableCopyWithZone:(nullable NSZone *)zone; 我们来准守NSCopying: 123@interface Person : NSObject &lt;NSCopying,NSMutableCopying&gt;...@end 实现copyWithZone: 12345678@implementation Person-(id)copyWithZone:(NSZone *zone)&#123; Person *p = [Person allocWithZone:zone]; p.name = _name; p.age = _age; p.height = _height; return p;&#125; 然后，声明对象p3为p1的拷贝: 1Person *p3 = [p1 copy]; 运行，查看: Foundation中的深浅拷贝NSString1234NSString *s1 = @"hello word";NSString *s2 = s1;NSString *s3 = [s1 copy];NSMutableString *s4 = [s1 mutableCopy]; 这里我们用字面量直接创建了一个不可变字符串s1,然后通过直接赋值和copy方式分别赋值给了s2,s3。实际上对于不可变字符串，这两个赋值方式效果是等价的，都是浅拷贝,都造成了引用计数增加1。为什么s4我用可变字符串来声明呢，因为对于不可变字符串进行mutableCopy，就会在内存中生成一个可变字符串对象，并把原来字符串的内容拿过来。 123//我们来对s4进行一些操作来确定s4确实是可变字符串[s4 appendString:@"!!!!"]; 结果:如果我们用可变字符串来声明s3,并调用可变字符串的方法，则会报错。 结论：对于NSString,直接赋值和copy都是浅拷贝, mutableCopy为深拷贝 NSMutableString我们直接用上面生成的可变字符串s4: 12NSMutableString *s5 = s4;[s5 appendString:@"##^_^"]; 查看运行后结果: 和我们预期的一样，s4的值随s5一起改变了，因为是浅拷贝，所指向的字符串对象是同一个。 我们接着操作: 12NSMutableString *s6 = [s4 copy];[s5 appendString:@"##~_~"]; 运行后，程序在appendString处崩溃，因为可变字符串执行copy实际上会在内存中生成一个内容相同的不可变字符串，是深拷贝。(ps：所以我们给一个类声明字符串类型的property时，通常使用copy,防止外部对字符串进行了改变影响到对象)。我们改为这样写: 1NSString *s6 = [s4 copy]; 接着我们来测试mutableCopy: 12NSMutableString *s7 = [s4 mutableCopy];[s7 appendString:@"##~_~"]; 运行没有任何问题，结果如下:可以看出,s7是一个可变对象，但是对s7的操作并没有影响到s4,s5。所以可变字符串执行mutableCopy，也是深拷贝，会在内存中生成一个新的内容一样的可变字符串。 结论：对于NSMutableString,直接赋值是浅拷贝, copy和mutableCopy都为深拷贝,copy会产生一个不可变字符串对象，而mutableCopy会产生一个可变字符串对象 容器类 此处以Arrary为例，NSSet,Dictionary一样。首先我们来看一下不可变数组，如下: 12345678Person *p1 = [[Person alloc]initWithName:@"p1" height:175 age:21];Person *p2 = [[Person alloc]initWithName:@"p2" height:176 age:22];Person *p3 = [[Person alloc]initWithName:@"p3" height:177 age:23]; NSArray *a1 = @[p1,p2,p3];NSArray *a2 = a1;NSArray *a3 = [a1 copy];NSArray *a4 = [a1 mutableCopy]; 运行后我们查看各个数组如下:我们可以看出直接赋值的a2和copy出的a3都是对a1浅拷贝，都是同一个数组对象。a4则是新的可变数组对象(虽然我用NSArray声明的a4,但是从打印结果可以看出a4是一个可变数组)，可其中的元素内容却还是一样的。可见对NSArrary的mutableCopy是对数组本身的深拷贝，但是对数组中的元素还是浅拷贝。 结论：对于不可变容器类, copy和直接赋值是浅拷贝，类容器对象本身和容器中的元素都是浅拷贝。mutableCopy为对容器对象本身的深拷贝,产生一个新的可变的容器对象，但是对于容器中的元素，为浅拷贝 我们接着用上面生成的a4来看一下可变数组的拷贝: 1234NSMutableArray *a4 = [a1 mutableCopy];//我们改用NSMutableArray声明NSMutableArray *a5 = a4;NSMutableArray *a6 = [a4 copy];NSMutableArray *a7 = [a4 mutableCopy]; 运行后我们查看各个数组如下:我们可以看出，直接赋值的a5是浅拷贝，copy出的a6，数组对象发生了变化，生成了一个新的不可变数组(虽然这里是NSMutableArray声明的，但是从打印结果可以看出是一个不可变数组)，但是元素内容依旧没有改变。所以是对容器对象深拷贝，其中元素的浅拷贝。使用mutableCopy，也是深拷贝，产生了一个新的可变数组，元素内容也没有改变。还是是对容器对象深拷贝，其中元素的浅拷贝。 结论：对于可变容器类, 直接赋值是浅拷贝，类容器对象本身和容器中的元素都是浅拷贝。copy和mutableCopy为对容器对象本身的深拷贝, copy产生一个新的不可变的容器、mutableCopy产生一个新的可变的容器对象，但是对于容器中的元素，为浅拷贝 ps:实际上，上面的所有直接赋值，都是retain的过程，是浅拷贝，但是引用计数会增加]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[授之以渔:Hexo+GitHub全平台快速搭建博客绝对详解（三）]]></title>
      <url>%2F2017%2F04%2F07%2Fmulti-platform-edit-add-domain-name-binding%2F</url>
      <content type="text"><![CDATA[本篇将介绍两点： 1.如何多台电脑同步编辑自己的博客 2.如何将自己的博客绑定自己的域名 多台电脑同步编辑自己的博客 在github或者coding,bitbucket等git代码托管平台上新建一个仓库，用来存放hexo项目源文件。这里建议不使用github，因为github上的私有仓库是收费的，而我们的源文件中可能包含很多token之类的隐私信息，所以放在私有仓库会比较安全。这里我使用的是coding。（ps:我们也可以把博客同时部署在coding或者bitbucket上，与github类似，请参考前面两篇） 将我们的hexo项目推送到建立好的远程仓库上，这里我们查看一下项目目录地下的 .gitignore文件中的内容，例如: .DS_Store Thumbs.db db.json *.log node_modules/ public/ .deploy*/ 代表我们的git将忽略这些文件，以上文件都可以忽略。 如果我们安装了一些主题 请把这些主题下的 .git 文件删掉，如果有的话，或者我们把主题当做子模块，不推荐这样做，因为你的主题肯定是被你编辑过的，当做子模块克隆的时候会从远主题地址重新可能，你的配置就费了。所以建议删除 .git，一起添加到git。 我们在需要编辑博客的电脑上配置好hexo需要的环境，将hexo项目克隆下来。完成后我们需要进入项目目录，执行一下: npm install 来安装依赖。结束后开始编辑你的博客吧！当我们结束改动后，把我们的操作推送到远程仓库上，其他电脑在编辑前先拉取一下就可以了，这样就保持了多台电脑都可以编辑我们的博客了。记住，编辑前我们先pull，编辑后我们要push。 Hexo域名绑定 首先你得有个域名，如果没有的话，去买一个吧，我这里在阿里购买了一个.top的域名，首年才4元。.com 的首年五十多这样。 配置域名解析如下，这里以阿里云和部署平台为github为例： 进入阿里云控制台-&gt;域名与网站（万网）-&gt; 域名。选择域名解析，设置如下:现在浏览器输入你的域名，是不是就直接可以访问博客了！！后来我将博客部署到了coding，解析设置如下: 后期我将继续介绍如何被百度谷歌收录及其他配置。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[授之以渔:Hexo+GitHub全平台快速搭建博客绝对详解（二）]]></title>
      <url>%2F2017%2F04%2F05%2Fhexo-on-git%2F</url>
      <content type="text"><![CDATA[Hexo的优越之处正是在于可以步数到GitHub等平台,在介绍完如果搭建使用Hexo之后，我们来详细介绍下如何方便快速的部署到GitHub。 本文在mac上写的，所以以mac为例，Linux类似。 建立博客的git仓库 首先，你得有一个GitHub的账号，如果没有请自行注册。 然后，建立一个仓库，命名为:&#8194;&lt;你的GitHub用户名&gt;.github.io&#8194; 。这里一定要以这种格式命名，这是固定格式，例如: zhangsan.github.io。 发布到GitHub 编辑hexo项目中的_config.yml文件,将deploy:修改如下: deploy: type: git repo: &lt;这里填你建立的博客仓库的地址,如: git@github.com:zhangsan/zhangsan.github.io.git&gt; branch: master 保存。 安装hexo-deployer-git: npm install hexo-deployer-git --save 生成和部署git,执行 hexo g -d 这是简写格式，更多信息可以参考官方文档的生成器和部署 。 部署过程中会提示你输入GitHub的用户名和密码，正确输入即可，后边将会介绍如何配置免输入直接部署。 部署完成后，浏览器输入 https://&lt;你的GitHub博客项目名&gt;,如我的博客https://swwgit.github.io。 是不是已经看到了自己的博客网站已经建好了呢 部署到GitHub的SSH配置 生成rsa秘钥 ssh-keygen -t rsa -C &quot;GitHub注册邮箱&quot; 回车，会提示你秘钥的保存路径，如果你有生成过其他秘钥，这里建议改名（=，否则会覆盖其他秘钥，或者你有多个GitHub账户之类的，为了区分，这里也建议你改名，但是不要改路径。如果你不改名，回车便可以了（如果你改名了,请看一下最底下的附：关于电脑上有多个GitHub账户和改名默认rsa文件后SSH GitHub失败的配置。）。 接着会提示你输入密码，这里是设置rsa加密文件的密码,不需要设置，一路回车就可以了。 设置GitHub的SSH Key 打开刚刚生成的秘钥对中的公钥,就是秘钥保存路径下的 秘钥文件名.pub 文件，如果 githubSSH_rsa.pub 。打开后，将文件中的内容全选拷贝。打开GitHub SSH设置,选择 New SSH Key ,将刚刚拷贝的内容粘贴到key中，Title自己随意取名或者不填都可以。点击 Add SSH key 完成添加。 设置Git全局配置 终端输入: git config --global user.name &quot;你的GitHub用户名&quot; git config --global user.email &quot;你的GitHub邮箱&quot; 测试GitHub连接 终端输入: ssh -T git@github.com 如果有警告请直接输入yes，提示 successfully 则代表上面SSH配置链接成功。 完成上面步骤后，进入hexo项目路径，执行 hexo g -d 是不是就可以自动部署到GitHub中了! 附：关于电脑上有多个GitHub账户和改名默认rsa文件后SSH GitHub失败的配置 如果电脑上有生成过SSH秘钥，那么在生成心得秘钥时，必然是要改名的，否则就会覆盖以前的，但是改名之后，系统是认不出的，所以需要自己配置下。 打开rsa秘钥的保存路径下的config文件,(如果没有，新建一个即可，没有后缀名)。 对应每添加一个GitHub账户，在文件中都要加入一份如下配置: Host github.com //GitHub的Host地址 HostName github.com //Host的名字 User zhangsan //用户 IdentityFile /Users/zhangsan/.ssh/zhangsan_git_rsa //rsa秘钥（私钥）的绝对路径 保存即可。 markdown编辑器推荐 atom :跨平台的编辑器，拥有很多插件，markdown的编辑和预览非常不错。 MacDown : mac平台上非常简洁好用的markdown专用的编辑器。 下一篇将详细介绍如何多在台电脑上编辑博客已经域名绑定。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[授之以渔:Hexo+GitHub全平台快速搭建博客绝对详解（一）]]></title>
      <url>%2F2017%2F04%2F01%2Fhowtousehexo%2F</url>
      <content type="text"><![CDATA[前言: 学习了很多，研究了很多，用上的却很少，总该写点什么了，便搭建了这个博客。所以第一篇，我就来详解一下如何用Hexo+GitHub搭建自己的博客。关于Hexo的使用，网上有很多参差不齐的介绍，这里我将一步步从头到尾的精讲一下。 关于Hexo的介绍，我就不多说了，用官方的话说就是： Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 之所以采用Hexo+GitHub搭建博客，除了简单好用，插件主题够多，最主要的原因是可以直接部署的GitHUb上，不需要租服务器。 环境部署Hexo的安装很简单,首先需要安装node.js和git安装git window: 下载安装git，推荐国内下载站。 配置git环境变量，将Git的安装目录下的bin目录路径添加的环境变量Path中，如 C:\Program Files\Git\bin。 Mac: 首先如果你的电脑没有安装Xcode 和 Xcode Command Line Tools 请先安装Xcode，App Store下载即可,然后打开终端输入 xcode-select --install 回车,一路安装即可,如果提示command line tools are already installed则代表已经安装过了。 安装HomeBrew，HomeBrew是mac下的一个包管理器。打开HomeBrew,复制页面中的 /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 粘贴到终端中，回车，安装。 安装MacPorts,打开MacPorts，下载对于自己系统版本的MacPorts,安装。 安装git,终端输入 brew install git 执行安装即可。 Linux (本教程以Ubuntu为例) 打开终端，输入 sudo apt-get install 执行安装即可。 安装Node.js(推荐使用nvm来管理安装node) windows: 直接下载,安装即可。安装时，请勾选Add to PATH选项。 或者参考这篇文章，使用nvm来安装配置node:nodejs在windows下的安装配置(使用NVM的方式) mac : 终端输入 brew install nvm 安装好nvm。 安装node,输入 nvm ls-remote 查看远端库里的node版本。如图: 选择node相应版本安装(同时会安装对应的npm)，如: nvm install v7.8.0 或者使用 nvm install stable 安装当前最稳定版本。 安装完成后,输入 node -v 查看版本号，检查是否安装成功。 我们可以安装多个版本，通过: nvm use &quot;版本号&quot; 来切换版本,如： Linux (本教程以Ubuntu为例) 终端输入 sudo apt-get update sudo apt-get install build-essential libssl-dev 安装必要的包。 进入nvm github 查看nvm的tag号,即已发布的版本号。 然后执行（版本号可对应替换） curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash 或者 wget -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash 安装成功后,关闭终端,重新打开终端,执行 nvm --version 查看nvm是否安装成功。 安装node,输入 nvm ls-remote 查看远端库里的node版本。如图: 选择node相应版本安装(同时会安装对应的npm)，如: nvm install v7.8.0 或者使用 nvm install stable 安装当前最稳定版本。 安装完成后,输入 node --vresion 查看版本号，检查是否安装成功。 我们可以安装多个版本，通过: nvm use &quot;版本号&quot; 来切换版本,如： 最后，重头戏到了 ,安装Hexo 执行 npm install -g hexo-cli – 开始使用 Hexo快速开始，终端输入 hexo init &lt;folder&gt; cd &lt;folder&gt; 或者 mkdir &lt;folder&gt; cd folder hexo init 生成项目后,可以直接运行 hexo server 然后浏览器打开 http://localhost:4000/,进行本地预览。 这一部分，可以直接阅读官方文档,可选选择中文，如果有不明白的地方，欢迎提问。关于主题使用，主题作者都是写明对应主题的使用方法。 下一篇将详细介绍如何部署到git和如何多台电脑编辑。]]></content>
    </entry>

    
  
  
</search>

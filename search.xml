<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[细谈OC中的深浅拷贝]]></title>
      <url>%2F2017%2F04%2F07%2Ftalking-aboult-oc-copy%2F</url>
      <content type="text"><![CDATA[关于深浅拷贝，已经是个老生常谈的问题了，自己曾经也有在面试中被问过，最近有个朋友问到过这个问题，借此机会，我们来细谈一下深浅拷贝的问题。 深浅拷贝的概念什么是深拷贝什么是浅拷贝呢，简单来说就是： 深拷贝是对一个对象的内容的拷贝，分配新的内存去存储。拷贝后的对象和原来的对象并不是同一个对象，只是内容一样而已。 浅拷贝则是对对象地址的拷贝，和原来的对象的内容是同一份，并没有分配新的内存。 深浅拷贝演示 我们定义一个Person类如下: 然后我们生成一个Person对象p1,再定义一个p2，将p1赋值给p2:这里实际上就是进行了一次浅拷贝，把p1的地址赋给了p2。p1和p2都是指向同一个对象,但是对象的引用计数增加了1。如果我们对p2的属性进行修改,则p1也会改变，因为操作的就是同一个对象。 如何进行深拷贝呢,我们可以遵守NSCopying,NSMutableCopying协议,实现: 12- (id)copyWithZone:(nullable NSZone *)zone;- (id)mutableCopyWithZone:(nullable NSZone *)zone; 我们来准守NSCopying, 1@interface Person : NSObject &lt;NSCopying,NSMutableCopying&gt; 1234567891011121314@implementation Person-(id)copyWithZone:(NSZone *)zone&#123; Person *p = [Person allocWithZone:zone]; p.name = _name; //因为属性name是在前面是通过copy声明，在赋值的时候会自动调用到copy,所以这里不需要 [_name copy] p.age = _age; p.height = _height; return p;&#125;``` 声明对象p3为p1的拷贝:```objcPerson *p3 = [p1 copy]; 运行，查看: Foundation中的深浅拷贝NSString1234NSString *s1 = @"hello word";NSString *s2 = s1;NSString *s3 = [s1 copy];NSMutableString *s4 = [s1 mutableCopy]; 这里我们用字面量直接创建了一个不可变字符串s1,然后通过直接赋值和copy方式分别赋值给了s2,s3。实际上对于不可变字符串，这两个赋值方式效果是等价的，都是浅拷贝,都造成了引用计数增加1。为什么s4我用可变字符串来声明呢，因为对于不可变字符串进行mutableCopy，就会在内存中生成一个可变字符串对象，并把原来字符串的内容拿过来。 123//我们来对s4进行一些操作来确定s4确实是可变字符串[s4 appendString:@"!!!!"]; 结果:如果我们用可变字符串来声明s3,并调用可变字符串的方法，则会报错。 结论：对于NSString,直接赋值和copy都是浅拷贝, mutableCopy为深拷贝 NSMutableString我们直接用上面生成的可变字符串s4: 12NSMutableString *s5 = s4;[s5 appendString:@"##^_^"]; 查看运行后结果: 和我们预期的一样，s4的值随s5一起改变了，因为是浅拷贝，所指向的字符串对象是同一个。 我们接着操作: 12NSMutableString *s6 = [s4 copy];[s5 appendString:@"##~_~"]; 运行后，程序在appendString处崩溃，因为可变字符串执行copy实际上会在内存中生成一个内容相同的不可变字符串，是深拷贝。(ps：所以我们给一个类声明字符串类型的property时，通常使用copy,防止外部对字符串进行了改变影响到对象)。我们改为这样写: 1NSString *s6 = [s4 copy]; 接着我们来测试mutableCopy: 12NSMutableString *s7 = [s4 mutableCopy];[s7 appendString:@"##~_~"]; 运行没有任何问题，结果如下:可以看出,s7是一个可变对象，但是对s7的操作并没有影响到s4,s5。所以可变字符串执行mutableCopy，也是深拷贝，会在内存中生成一个新的内容一样的可变字符串。 结论：对于NSMutableString,直接赋值是浅拷贝, copy和mutableCopy都为深拷贝,copy会产生一个不可变字符串对象，而mutableCopy会产生一个可变字符串对象 未完待续……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[细谈OC中的深浅拷贝]]></title>
      <url>%2F2017%2F04%2F07%2Ftalking-about-oc-copy%2F</url>
      <content type="text"><![CDATA[关于深浅拷贝，已经是个老生常谈的问题了，自己曾经也有在面试中被问过，最近有个朋友问到过这个问题，借此机会，我们来细谈一下深浅拷贝的问题。 深浅拷贝的概念什么是深拷贝什么是浅拷贝呢，简单来说就是： 深拷贝是对一个对象的内容的拷贝，分配新的内存去存储。拷贝后的对象和原来的对象并不是同一个对象，只是内容一样而已。 浅拷贝则是对对象地址的拷贝，和原来的对象的内容是同一份，并没有分配新的内存。 深浅拷贝演示 我们定义一个Person类如下: 然后我们生成一个Person对象p1,再定义一个p2，将p1赋值给p2:这里实际上就是进行了一次浅拷贝，把p1的地址赋给了p2。p1和p2都是指向同一个对象,但是对象的引用计数增加了1。如果我们对p2的属性进行修改,则p1也会改变，因为操作的就是同一个对象。 如何进行深拷贝呢,我们可以遵守NSCopying,NSMutableCopying协议,实现: 12- (id)copyWithZone:(nullable NSZone *)zone;- (id)mutableCopyWithZone:(nullable NSZone *)zone; 我们来准守NSCopying, 1@interface Person : NSObject &lt;NSCopying,NSMutableCopying&gt; 1234567891011121314@implementation Person-(id)copyWithZone:(NSZone *)zone&#123; Person *p = [Person allocWithZone:zone]; p.name = _name; //因为属性name是在前面是通过copy声明，在赋值的时候会自动调用到copy,所以这里不需要 [_name copy] p.age = _age; p.height = _height; return p;&#125;``` 声明对象p3为p1的拷贝:```objcPerson *p3 = [p1 copy]; 运行，查看: Foundation中的深浅拷贝NSString1234NSString *s1 = @"hello word";NSString *s2 = s1;NSString *s3 = [s1 copy];NSMutableString *s4 = [s1 mutableCopy]; 这里我们用字面量直接创建了一个不可变字符串s1,然后通过直接赋值和copy方式分别赋值给了s2,s3。实际上对于不可变字符串，这两个赋值方式效果是等价的，都是浅拷贝,都造成了引用计数增加1。为什么s4我用可变字符串来声明呢，因为对于不可变字符串进行mutableCopy，就会在内存中生成一个可变字符串对象，并把原来字符串的内容拿过来。 123//我们来对s4进行一些操作来确定s4确实是可变字符串[s4 appendString:@"!!!!"]; 结果:如果我们用可变字符串来声明s3,并调用可变字符串的方法，则会报错。 结论：对于NSString,直接赋值和copy都是浅拷贝, mutableCopy为深拷贝 NSMutableString我们直接用上面生成的可变字符串s4: 12NSMutableString *s5 = s4;[s5 appendString:@"##^_^"]; 查看运行后结果: 和我们预期的一样，s4的值随s5一起改变了，因为是浅拷贝，所指向的字符串对象是同一个。 我们接着操作: 12NSMutableString *s6 = [s4 copy];[s5 appendString:@"##~_~"]; 运行后，程序在appendString处崩溃，因为可变字符串执行copy实际上会在内存中生成一个内容相同的不可变字符串，是深拷贝。(ps：所以我们给一个类声明字符串类型的property时，通常使用copy,防止外部对字符串进行了改变影响到对象)。我们改为这样写: 1NSString *s6 = [s4 copy]; 接着我们来测试mutableCopy: 12NSMutableString *s7 = [s4 mutableCopy];[s7 appendString:@"##~_~"]; 运行没有任何问题，结果如下:可以看出,s7是一个可变对象，但是对s7的操作并没有影响到s4,s5。所以可变字符串执行mutableCopy，也是深拷贝，会在内存中生成一个新的内容一样的可变字符串。 结论：对于NSMutableString,直接赋值是浅拷贝, copy和mutableCopy都为深拷贝,copy会产生一个不可变字符串对象，而mutableCopy会产生一个可变字符串对象 未完待续……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[授之以渔:Hexo+GitHub全平台快速搭建博客绝对详解（三）]]></title>
      <url>%2F2017%2F04%2F07%2Fmulti-platform-edit-add-domain-name-binding%2F</url>
      <content type="text"><![CDATA[本篇将介绍两点： 1.如何多台电脑同步编辑自己的博客 2.如何将自己的博客绑定自己的域名 多台电脑同步编辑自己的博客 在github或者coding,bitbucket等git代码托管平台上新建一个仓库，用来存放hexo项目源文件。这里建议不使用github，因为github上的私有仓库是收费的，而我们的源文件中可能包含很多token之类的隐私信息，所以放在私有仓库会比较安全。这里我使用的是coding。（ps:我们也可以把博客同时部署在coding或者bitbucket上，与github类似，请参考前面两篇） 将我们的hexo项目推送到建立好的远程仓库上，这里我们查看一下项目目录地下的 .gitignore文件中的内容，例如: .DS_Store Thumbs.db db.json *.log node_modules/ public/ .deploy*/ 代表我们的git将忽略这些文件，以上文件都可以忽略。 如果我们安装了一些主题 请把这些主题下的 .git 文件删掉，如果有的话，或者我们把主题当做子模块，不推荐这样做，因为你的主题肯定是被你编辑过的，当做子模块克隆的时候会从远主题地址重新可能，你的配置就费了。所以建议删除 .git，一起添加到git。 我们在需要编辑博客的电脑上配置好hexo需要的环境，将hexo项目克隆下来。完成后我们需要进入项目目录，执行一下: npm install 来安装依赖。结束后开始编辑你的博客吧！当我们结束改动后，把我们的操作推送到远程仓库上，其他电脑在编辑前先拉取一下就可以了，这样就保持了多台电脑都可以编辑我们的博客了。记住，编辑前我们先pull，编辑后我们要push。 Hexo域名绑定 首先你得有个域名，如果没有的话，去买一个吧，我这里在阿里购买了一个.top的域名，首年才4元。.com 的首年五十多这样。 配置域名解析如下，这里以阿里云和部署平台为github为例： 进入阿里云控制台-&gt;域名与网站（万网）-&gt; 域名。选择域名解析，设置如下:现在浏览器输入你的域名，是不是就直接可以访问博客了！！后来我将博客部署到了coding，解析设置如下: 后期我将继续介绍如何被百度谷歌收录及其他配置。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[授之以渔:Hexo+GitHub全平台快速搭建博客绝对详解（二）]]></title>
      <url>%2F2017%2F04%2F05%2Fhexo-on-git%2F</url>
      <content type="text"><![CDATA[Hexo的优越之处正是在于可以步数到GitHub等平台,在介绍完如果搭建使用Hexo之后，我们来详细介绍下如何方便快速的部署到GitHub。 本文在mac上写的，所以以mac为例，Linux类似。 建立博客的git仓库 首先，你得有一个GitHub的账号，如果没有请自行注册。 然后，建立一个仓库，命名为:&#8194;&lt;你的GitHub用户名&gt;.github.io&#8194; 。这里一定要以这种格式命名，这是固定格式，例如: zhangsan.github.io。 发布到GitHub 编辑hexo项目中的_config.yml文件,将deploy:修改如下: deploy: type: git repo: &lt;这里填你建立的博客仓库的地址,如: git@github.com:zhangsan/zhangsan.github.io.git&gt; branch: master 保存。 安装hexo-deployer-git: npm install hexo-deployer-git --save 生成和部署git,执行 hexo g -d 这是简写格式，更多信息可以参考官方文档的生成器和部署 。 部署过程中会提示你输入GitHub的用户名和密码，正确输入即可，后边将会介绍如何配置免输入直接部署。 部署完成后，浏览器输入 https://&lt;你的GitHub博客项目名&gt;,如我的博客https://swwgit.github.io。 是不是已经看到了自己的博客网站已经建好了呢 部署到GitHub的SSH配置 生成rsa秘钥 ssh-keygen -t rsa -C &quot;GitHub注册邮箱&quot; 回车，会提示你秘钥的保存路径，如果你有生成过其他秘钥，这里建议改名（=，否则会覆盖其他秘钥，或者你有多个GitHub账户之类的，为了区分，这里也建议你改名，但是不要改路径。如果你不改名，回车便可以了（如果你改名了,请看一下最底下的附：关于电脑上有多个GitHub账户和改名默认rsa文件后SSH GitHub失败的配置。）。 接着会提示你输入密码，这里是设置rsa加密文件的密码,不需要设置，一路回车就可以了。 设置GitHub的SSH Key 打开刚刚生成的秘钥对中的公钥,就是秘钥保存路径下的 秘钥文件名.pub 文件，如果 githubSSH_rsa.pub 。打开后，将文件中的内容全选拷贝。打开GitHub SSH设置,选择 New SSH Key ,将刚刚拷贝的内容粘贴到key中，Title自己随意取名或者不填都可以。点击 Add SSH key 完成添加。 设置Git全局配置 终端输入: git config --global user.name &quot;你的GitHub用户名&quot; git config --global user.email &quot;你的GitHub邮箱&quot; 测试GitHub连接 终端输入: ssh -T git@github.com 如果有警告请直接输入yes，提示 successfully 则代表上面SSH配置链接成功。 完成上面步骤后，进入hexo项目路径，执行 hexo g -d 是不是就可以自动部署到GitHub中了! 附：关于电脑上有多个GitHub账户和改名默认rsa文件后SSH GitHub失败的配置 如果电脑上有生成过SSH秘钥，那么在生成心得秘钥时，必然是要改名的，否则就会覆盖以前的，但是改名之后，系统是认不出的，所以需要自己配置下。 打开rsa秘钥的保存路径下的config文件,(如果没有，新建一个即可，没有后缀名)。 对应每添加一个GitHub账户，在文件中都要加入一份如下配置: Host github.com //GitHub的Host地址 HostName github.com //Host的名字 User zhangsan //用户 IdentityFile /Users/zhangsan/.ssh/zhangsan_git_rsa //rsa秘钥（私钥）的绝对路径 保存即可。 markdown编辑器推荐 atom :跨平台的编辑器，拥有很多插件，markdown的编辑和预览非常不错。 MacDown : mac平台上非常简洁好用的markdown专用的编辑器。 下一篇将详细介绍如何多在台电脑上编辑博客已经域名绑定。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[授之以渔:Hexo+GitHub全平台快速搭建博客绝对详解（一）]]></title>
      <url>%2F2017%2F04%2F01%2Fhowtousehexo%2F</url>
      <content type="text"><![CDATA[前言: 学习了很多，研究了很多，用上的却很少，总该写点什么了，便搭建了这个博客。所以第一篇，我就来详解一下如何用Hexo+GitHub搭建自己的博客。关于Hexo的使用，网上有很多参差不齐的介绍，这里我将一步步从头到尾的精讲一下。 关于Hexo的介绍，我就不多说了，用官方的话说就是： Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 之所以采用Hexo+GitHub搭建博客，除了简单好用，插件主题够多，最主要的原因是可以直接部署的GitHUb上，不需要租服务器。 环境部署Hexo的安装很简单,首先需要安装node.js和git安装git window: 下载安装git，推荐国内下载站。 配置git环境变量，将Git的安装目录下的bin目录路径添加的环境变量Path中，如 C:\Program Files\Git\bin。 Mac: 首先如果你的电脑没有安装Xcode 和 Xcode Command Line Tools 请先安装Xcode，App Store下载即可,然后打开终端输入 xcode-select --install 回车,一路安装即可,如果提示command line tools are already installed则代表已经安装过了。 安装HomeBrew，HomeBrew是mac下的一个包管理器。打开HomeBrew,复制页面中的 /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 粘贴到终端中，回车，安装。 安装MacPorts,打开MacPorts，下载对于自己系统版本的MacPorts,安装。 安装git,终端输入 brew install git 执行安装即可。 Linux (本教程以Ubuntu为例) 打开终端，输入 sudo apt-get install 执行安装即可。 安装Node.js(推荐使用nvm来管理安装node) windows: 直接下载,安装即可。安装时，请勾选Add to PATH选项。 或者参考这篇文章，使用nvm来安装配置node:nodejs在windows下的安装配置(使用NVM的方式) mac : 终端输入 brew install nvm 安装好nvm。 安装node,输入 nvm ls-remote 查看远端库里的node版本。如图: 选择node相应版本安装(同时会安装对应的npm)，如: nvm install v7.8.0 或者使用 nvm install stable 安装当前最稳定版本。 安装完成后,输入 node -v 查看版本号，检查是否安装成功。 我们可以安装多个版本，通过: nvm use &quot;版本号&quot; 来切换版本,如： Linux (本教程以Ubuntu为例) 终端输入 sudo apt-get update sudo apt-get install build-essential libssl-dev 安装必要的包。 进入nvm github 查看nvm的tag号,即已发布的版本号。 然后执行（版本号可对应替换） curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash 或者 wget -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash 安装成功后,关闭终端,重新打开终端,执行 nvm --version 查看nvm是否安装成功。 安装node,输入 nvm ls-remote 查看远端库里的node版本。如图: 选择node相应版本安装(同时会安装对应的npm)，如: nvm install v7.8.0 或者使用 nvm install stable 安装当前最稳定版本。 安装完成后,输入 node --vresion 查看版本号，检查是否安装成功。 我们可以安装多个版本，通过: nvm use &quot;版本号&quot; 来切换版本,如： 最后，重头戏到了 ,安装Hexo 执行 npm install -g hexo-cli – 开始使用 Hexo快速开始，终端输入 hexo init &lt;folder&gt; cd &lt;folder&gt; 或者 mkdir &lt;folder&gt; cd folder hexo init 生成项目后,可以直接运行 hexo server 然后浏览器打开 http://localhost:4000/,进行本地预览。 这一部分，可以直接阅读官方文档,可选选择中文，如果有不明白的地方，欢迎提问。关于主题使用，主题作者都是写明对应主题的使用方法。 下一篇将详细介绍如何部署到git和如何多台电脑编辑。]]></content>
    </entry>

    
  
  
</search>
